-- Restore RLS policies to previous baseline:
-- 1) Global admin-only across tables (as per admin_lockdown_all_tables.sql)
-- 2) Products: verified-only SELECT (as per products_verified_only.sql)
-- 3) Keep products_public view readable by anon (storefront)

-- Ensure helpers exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_proc p JOIN pg_namespace n ON n.oid=p.pronamespace
    WHERE n.nspname='public' AND p.proname='current_user_is_admin' AND p.pronargs=0
  ) THEN
    CREATE OR REPLACE FUNCTION public.current_user_is_admin()
    RETURNS boolean LANGUAGE sql AS 'SELECT false';
  END IF;
END $$;

CREATE OR REPLACE FUNCTION public.current_user_is_admin()
RETURNS boolean
LANGUAGE sql
STABLE SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
  SELECT coalesce((SELECT (auth.jwt() -> 'app_metadata' ->> 'role') = 'admin'), false);
$$;

-- Apply admin-only RLS to every BASE TABLE in public we own
DO $$
DECLARE r record;
DECLARE pol record;
BEGIN
  FOR r IN
    SELECT schemaname AS table_schema, tablename AS table_name
    FROM pg_tables
    WHERE schemaname = 'public'
      AND tableowner = current_user
    ORDER BY schemaname, tablename
  LOOP
    EXECUTE format('ALTER TABLE %I.%I ENABLE ROW LEVEL SECURITY', r.table_schema, r.table_name);

    -- Drop all existing policies on the table
    FOR pol IN
      SELECT policyname FROM pg_policies
      WHERE schemaname = r.table_schema AND tablename = r.table_name
    LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON %I.%I', pol.policyname, r.table_schema, r.table_name);
    END LOOP;

    -- Create admin-only SELECT policy
    EXECUTE format(
      'CREATE POLICY %I ON %I.%I FOR SELECT TO authenticated USING (public.current_user_is_admin())',
      r.table_name || '_admin_select', r.table_schema, r.table_name
    );

    -- Create admin-only CRUD policy
    EXECUTE format(
      'CREATE POLICY %I ON %I.%I FOR ALL TO authenticated USING (public.current_user_is_admin()) WITH CHECK (public.current_user_is_admin())',
      r.table_name || '_admin_all', r.table_schema, r.table_name
    );
  END LOOP;
END $$;

-- Override products table to verified-only SELECT (drop admin-only select and add verified-only)
DO $$
DECLARE pol RECORD;
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='products'
  ) THEN
    FOR pol IN SELECT policyname FROM pg_policies WHERE schemaname='public' AND tablename='products' LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON public.products', pol.policyname);
    END LOOP;

    -- Verified-only SELECT
    CREATE POLICY products_verified_select
      ON public.products
      FOR SELECT
      TO authenticated
      USING (
        EXISTS (
          SELECT 1 FROM public.user_roles ur
          WHERE ur.user_id = (SELECT auth.uid())
            AND ur.role = 'verified'
        )
      );

    -- Admin-only ALL
    CREATE POLICY products_admin_all
      ON public.products
      FOR ALL
      TO authenticated
      USING (public.current_user_is_admin())
      WITH CHECK (public.current_user_is_admin());
  END IF;
END $$;

-- Recreate/ensure products_public view and grants
CREATE OR REPLACE VIEW public.products_public AS
  SELECT id, name, description, price, image_url, is_active
  FROM public.products
  WHERE is_active = true;

REVOKE ALL ON public.products_public FROM PUBLIC;
GRANT SELECT ON public.products_public TO anon;
-- (Do not grant to authenticated explicitly in this baseline)
