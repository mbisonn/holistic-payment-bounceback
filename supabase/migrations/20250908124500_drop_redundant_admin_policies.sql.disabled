-- Drop redundant per-table admin_* policies now that admin_bypass_all exists.
-- Keeps consolidated/non-admin SELECT policies in place.

DO $$
DECLARE
  rec RECORD;
BEGIN
  FOR rec IN
    SELECT schemaname, tablename, policyname
    FROM pg_policies
    WHERE schemaname = 'public'
      AND policyname ILIKE '%admin_%'
      AND policyname <> 'admin_bypass_all'
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS %I ON %I.%I', rec.policyname, rec.schemaname, rec.tablename);
    RAISE NOTICE 'Dropped policy % on %.%', rec.policyname, rec.schemaname, rec.tablename;
  END LOOP;
END $$ LANGUAGE plpgsql;

-- Optional: ensure a single SELECT policy exists for authenticated where needed.
-- (No-op if already present from earlier consolidations.)
DO $$
DECLARE
  t text;
BEGIN
  FOREACH t IN ARRAY ARRAY[
    'automation_rules',
    'customer_analytics',
    'customer_tag_assignments',
    'customer_tags',
    'discount_codes',
    'email_analytics',
    'email_campaigns',
    'email_events',
    'email_logs',
    'email_outbox',
    'email_settings',
    'email_templates',
    'invoices',
    'meal_plan_sync',
    'order_bumps',
    'orders',
    'products',
    'profiles',
    'shipping_settings',
    'upsell_products',
    'workflow_steps',
    'user_roles',
    'user_access_requests'
  ]
  LOOP
    IF EXISTS (
      SELECT 1 FROM pg_class c JOIN pg_namespace n ON n.oid = c.relnamespace
      WHERE n.nspname='public' AND c.relname=t
    ) THEN
      IF NOT EXISTS (
        SELECT 1 FROM pg_policies 
        WHERE schemaname='public' AND tablename=t AND cmd='SELECT' AND roles @> ARRAY['authenticated']::name[]
      ) THEN
        EXECUTE format('CREATE POLICY %I ON public.%I FOR SELECT TO authenticated USING (true)', t || '_select_consolidated', t);
      END IF;
    END IF;
  END LOOP;
END $$ LANGUAGE plpgsql;

