-- Drop all overloads of public.assign_user_role, then recreate the uuid variant
DO $$
DECLARE
  fn record;
BEGIN
  FOR fn IN
    SELECT p.oid, n.nspname AS schema, p.proname, oidvectortypes(p.proargtypes) AS argtypes
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public' AND p.proname = 'assign_user_role'
  LOOP
    EXECUTE format('DROP FUNCTION IF EXISTS %I.%I(%s);', fn.schema, fn.proname, fn.argtypes);
  END LOOP;
END $$;

-- Recreate only the intended uuid variant
CREATE OR REPLACE FUNCTION public.assign_user_role(p_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SET search_path = public, auth
AS $$
DECLARE
  desired_role text;
BEGIN
  SELECT COALESCE(u.raw_app_meta_data->>'role', 'viewer')
    INTO desired_role
  FROM auth.users u
  WHERE u.id = p_user_id;

  IF desired_role NOT IN ('admin','manager','editor','viewer') THEN
    desired_role := 'viewer';
  END IF;

  UPDATE public.user_roles
     SET role = desired_role::public.app_role
   WHERE user_id = p_user_id;

  IF NOT FOUND THEN
    INSERT INTO public.user_roles (user_id, role)
    VALUES (p_user_id, desired_role::public.app_role);
  END IF;
END;
$$;
