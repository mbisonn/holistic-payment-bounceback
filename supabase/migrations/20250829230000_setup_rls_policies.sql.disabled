-- Enable Row Level Security on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;

-- Create a function to check if user is admin based on JWT claims (non-recursive)
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  jwt jsonb;
BEGIN
  BEGIN
    jwt := current_setting('request.jwt.claims', true)::jsonb;
  EXCEPTION WHEN others THEN
    jwt := NULL;
  END;

  IF jwt IS NULL THEN
    RETURN false;
  END IF;

  RETURN coalesce((jwt -> 'app_metadata' ->> 'role') = 'admin', false)
      OR coalesce((jwt ->> 'role') = 'admin', false);
END;
$$;

-- Create a function to get the current user's ID
CREATE OR REPLACE FUNCTION public.current_user_id()
RETURNS uuid
LANGUAGE sql
STABLE
AS $$
  SELECT auth.uid();
$$;

-- Profiles table policies
CREATE POLICY "Users can view all profiles"
  ON public.profiles
  FOR SELECT
  USING (true);

CREATE POLICY "Users can update their own profile"
  ON public.profiles
  FOR UPDATE
  USING (id = current_user_id() OR is_admin());

-- User roles policies
CREATE POLICY "Admins can manage all user roles"
  ON public.user_roles
  FOR ALL
  USING (is_admin());

CREATE POLICY "Users can view their own roles"
  ON public.user_roles
  FOR SELECT
  USING (user_id = current_user_id() OR is_admin());

-- Products table policies
CREATE POLICY "Anyone can view products"
  ON public.products
  FOR SELECT
  USING (true);

CREATE POLICY "Admins can manage products"
  ON public.products
  FOR ALL
  USING (is_admin());

-- Orders table policies
CREATE POLICY "Users can view their own orders"
  ON public.orders
  FOR SELECT
  USING (customer_email IN (
    SELECT email FROM auth.users WHERE id = current_user_id()
  ) OR is_admin());

CREATE POLICY "Admins can manage all orders"
  ON public.orders
  FOR ALL
  USING (is_admin());

-- Order items policies
CREATE POLICY "Users can view their own order items"
  ON public.order_items
  FOR SELECT
  USING (order_id IN (
    SELECT id FROM public.orders 
    WHERE customer_email IN (
      SELECT email FROM auth.users WHERE id = current_user_id()
    )
  ) OR is_admin());

CREATE POLICY "Admins can manage all order items"
  ON public.order_items
  FOR ALL
  USING (is_admin());

-- Email settings policies (admin only)
CREATE POLICY "Admins can manage email settings"
  ON public.email_settings
  FOR ALL
  USING (is_admin());

-- Email templates policies (admin only)
CREATE POLICY "Admins can manage email templates"
  ON public.email_templates
  FOR ALL
  USING (is_admin());

-- Email campaigns policies (admin only)
CREATE POLICY "Admins can manage email campaigns"
  ON public.email_campaigns
  FOR ALL
  USING (is_admin());

-- Create a trigger to automatically add admin role to specified emails
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Add user to profiles
  INSERT INTO public.profiles (id, email, full_name, role)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'full_name',
    CASE 
      WHEN NEW.email IN (
        'ebuchenna1@gmail.com',
        'info@bouncebacktolifeconsult.pro',
        'bouncebacktolifeconsult@gmail.com'
      ) THEN 'admin'
      ELSE 'user'
    END
  )
  ON CONFLICT (id) DO UPDATE
  SET email = EXCLUDED.email,
      full_name = EXCLUDED.full_name;
  
  -- Add admin role if email matches
  IF NEW.email IN (
    'ebuchenna1@gmail.com',
    'info@bouncebacktolifeconsult.pro',
    'bouncebacktolifeconsult@gmail.com'
  ) THEN
    INSERT INTO public.user_roles (user_id, role)
    VALUES (NEW.id, 'admin')
    ON CONFLICT (user_id, role) DO NOTHING;
  END IF;
  
  RETURN NEW;
END;
$$;

-- Create the trigger if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger 
    WHERE tgname = 'on_auth_user_created'
  ) THEN
    CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
  END IF;
END $$;

-- Create a function to promote users to admin (can only be called by existing admins)
CREATE OR REPLACE FUNCTION public.promote_to_admin(target_user_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF NOT is_admin() THEN
    RAISE EXCEPTION 'Only admins can promote users';
  END IF;
  
  -- Update profile role
  UPDATE public.profiles
  SET role = 'admin'
  WHERE id = target_user_id;
  
  -- Add admin role
  INSERT INTO public.user_roles (user_id, role)
  VALUES (target_user_id, 'admin')
  ON CONFLICT (user_id, role) DO NOTHING;
  
  -- Log the action
  RAISE NOTICE 'User % has been promoted to admin', target_user_id;
END;
$$;
